# SSI (Stationary Signal-Independent) additive noise augmentation from RawBoost.
#
# Algorithm overview:
#   1. Generate white Gaussian noise (flat spectrum, same length as input).
#   2. Build a random "colored" filter to reshape that noise:
#      - For each of `num_bands` bands, design a bandpass FIR kernel with a
#        random center frequency, bandwidth, and filter order (higher order
#        = sharper roll-off). Convolve all kernels together into one composite
#        FIR filter, then normalize its gain in the frequency domain.
#      This gives the noise a realistic, non-uniform spectral shape rather than
#      leaving it as plain white noise.
#   3. Filter the white noise through the composite FIR and peak-normalize it.
#   4. Pick a random target SNR (in dB) and scale the colored noise so that
#      its energy relative to the original signal matches that SNR:
#        noise_scaled = noise * (||signal||₂ / ||noise||₂) / 10^(0.05·SNR)
#   5. Add the scaled noise to the original audio and return.
#
# The result is a data-augmentation transform that adds differently-colored
# background noise at a random loudness each time it is called.

from dataclasses import dataclass
from typing import Optional, Union

import numpy as np
from numpy.typing import NDArray
from scipy import signal


@dataclass
class SSINoiseConfig:
    """Parameters for stationary signal-independent (SSI) additive noise.

    Noise is generated by filtering white Gaussian noise through a random
    multi-band FIR filter, then scaling it to achieve a target SNR.
    """

    snr_min: float = 10
    snr_max: float = 40
    num_bands: int = 5
    freq_lo: float = 20  # Hz, min center frequency of notch bands
    freq_hi: float = 8000  # Hz, max center frequency (< sample_rate / 2)
    bw_lo: float = 100  # Hz, min bandwidth per band
    bw_hi: float = 1000  # Hz, max bandwidth per band
    order_lo: int = 10  # min FIR filter order per band
    order_hi: int = 100  # max FIR filter order per band
    gain_lo: float = 0  # dB, min gain for the composite filter
    gain_hi: float = 0  # dB, max gain for the composite filter
    sample_rate: int = 16_000


class SSINoiseAugment:
    """Stationary signal-independent noise augmentation.

    Adds colored noise shaped by a random multi-band FIR filter, scaled to a
    uniformly sampled SNR in [snr_min, snr_max] dB.
    """

    def __init__(self, cfg: Optional[SSINoiseConfig] = None) -> None:
        self.cfg = cfg or SSINoiseConfig()

    def __call__(self, audio: NDArray[np.floating]) -> NDArray[np.floating]:
        """Add colored stationary noise to *audio* at a random SNR."""
        white = np.random.normal(0, 1, audio.shape[0])

        fir = self._build_composite_fir()
        colored = self._apply_fir(white, fir)
        colored = self._peak_normalize(colored, force=True)

        target_snr = self._sample_uniform(self.cfg.snr_min, self.cfg.snr_max)
        colored_norm = np.sqrt(
            np.sum(np.square(colored))
        )  # faster than using np.linalg.norm(colored, 2)
        audio_norm = np.sqrt(
            np.sum(np.square(audio))
        )  # faster than using np.linalg.norm(audio, 2)
        scaled_noise = colored / colored_norm * audio_norm / 10.0 ** (0.05 * target_snr)

        return audio + scaled_noise

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _build_composite_fir(self) -> NDArray[np.floating]:
        """Build a random multi-band FIR by convolving individual bandpass kernels.

        The composite filter is gain-normalized in the frequency domain.
        """
        cfg = self.cfg
        composite: Union[NDArray[np.floating], int] = 1
        for _ in range(cfg.num_bands):
            center = self._sample_uniform(cfg.freq_lo, cfg.freq_hi)
            bandwidth = self._sample_uniform(cfg.bw_lo, cfg.bw_hi)
            order = self._sample_uniform(cfg.order_lo, cfg.order_hi, as_integer=True)

            taps = self._random_bandpass_taps(center, bandwidth, order, cfg.sample_rate)
            composite = np.convolve(taps, composite)

        gain_db = self._sample_uniform(cfg.gain_lo, cfg.gain_hi)
        _, freq_response = signal.freqz(composite, 1, fs=cfg.sample_rate)
        composite = 10 ** (gain_db / 20) * composite / np.amax(np.abs(freq_response))
        return composite

    @staticmethod
    def _sample_uniform(
        low: float, high: float, as_integer: bool = False
    ) -> Union[int, NDArray[np.floating]]:
        """Draw a single sample from U(low, high), optionally truncated to int."""
        val = np.random.uniform(low, high, size=(1,))
        return int(val) if as_integer else val

    @staticmethod
    def _peak_normalize(
        waveform: NDArray[np.floating], force: bool = False
    ) -> NDArray[np.floating]:
        """Scale waveform so peak |amplitude| equals 1.

        When *force* is False, only normalizes if the peak exceeds 1.
        """
        peak = np.amax(np.abs(waveform))
        if force or peak > 1:
            waveform = waveform / peak
        return waveform

    @staticmethod
    def _random_bandpass_taps(
        center: float,
        bandwidth: float,
        order: int,
        sample_rate: float,
    ) -> NDArray[np.floating]:
        """Design a single Hamming-windowed bandpass FIR kernel."""
        if order % 2 == 0:
            order += 1

        lo_edge = center - bandwidth / 2
        hi_edge = center + bandwidth / 2
        if lo_edge <= 0:
            lo_edge = 1e-3
        if hi_edge >= sample_rate / 2:
            hi_edge = sample_rate / 2 - 1e-3

        return signal.firwin(
            order, [float(lo_edge), float(hi_edge)], window="hamming", fs=sample_rate
        )

    @staticmethod
    def _apply_fir(
        audio: NDArray[np.floating], coeffs: NDArray[np.floating]
    ) -> NDArray[np.floating]:
        """Apply an FIR filter with zero-padding and centered trimming to preserve length."""
        # lfilter (time-domain) beats fftconvolve here: ~500-tap filter on
        # ~64k samples — the FFT setup overhead outweighs the O(N log N) advantage.
        pad_len = coeffs.shape[0] + 1
        padded = np.pad(audio, (0, pad_len), mode="constant")
        filtered = signal.lfilter(coeffs, 1, padded)
        start = int(pad_len / 2)
        end = int(filtered.shape[0] - pad_len / 2)
        return filtered[start:end]
